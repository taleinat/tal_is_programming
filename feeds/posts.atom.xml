<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Tal is Programming - posts</title><link href="https://taleinat.github.io/tal_is_programming/" rel="alternate"></link><link href="https://taleinat.github.io/tal_is_programming/feeds/posts.atom.xml" rel="self"></link><id>https://taleinat.github.io/tal_is_programming/</id><updated>2018-09-24T00:00:00+03:00</updated><entry><title>Decoding Base 64</title><link href="https://taleinat.github.io/tal_is_programming/decoding-base-64.html" rel="alternate"></link><published>2018-09-24T00:00:00+03:00</published><updated>2018-09-24T00:00:00+03:00</updated><author><name>Tal Einat</name></author><id>tag:taleinat.github.io,2018-09-24:/tal_is_programming/decoding-base-64.html</id><summary type="html">&lt;p&gt;As a core Python developer, I recently worked on &lt;a href="https://bugs.python.org/issue33770"&gt;bug #33770: "base64 throws 'incorrect padding' exception when the issue is NOT with the padding"&lt;/a&gt;. It turns out that in addition to failing due to invalid characters or missing padding, decodeing base 64 can also fail due to invalid length.&lt;/p&gt;
&lt;p&gt;The â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;As a core Python developer, I recently worked on &lt;a href="https://bugs.python.org/issue33770"&gt;bug #33770: "base64 throws 'incorrect padding' exception when the issue is NOT with the padding"&lt;/a&gt;. It turns out that in addition to failing due to invalid characters or missing padding, decodeing base 64 can also fail due to invalid length.&lt;/p&gt;
&lt;p&gt;The reason: When encoding with base64, the number of output data bytes (not including '=' padding bytes) may be 0, 2, or 3 more than a multiple of 4, &lt;strong&gt;but never 1&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Input&lt;/th&gt;
&lt;th&gt;Output&lt;/th&gt;
&lt;th align="center"&gt;Length (mod 4)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;""&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;""&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"a"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;"YQ=="&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"ab"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;"YWI="&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"abc"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;"YWJj"&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"abcd"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;"YWJjZA=="&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"abcde"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;"YWJjZGU="&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"abcdef"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;"YWJjZGVm"&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;When attempting to decode base64-encoded data, if the number of data bytes is 1 more than a multiple of 4, there is no possible input that could have resulted in such output. Therefore, such inputs should be rejected as invalid.&lt;/p&gt;
&lt;h2&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;Storing or transferring data using &lt;em&gt;only&lt;/em&gt; base64 encoding is &lt;strong&gt;a bad idea&lt;/strong&gt;. A more appropriate format would include some facilities for error detection and/or correction, such as being able to tell whether the encoded data has been truncated. Unfortunately, I can't think of anything nearly as ubiquitous as base64 that includes even basic error detection features. Maybe it's time to create something like this?&lt;/p&gt;</content></entry></feed>